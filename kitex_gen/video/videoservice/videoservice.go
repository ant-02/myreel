// Code generated by Kitex v0.15.2. DO NOT EDIT.

package videoservice

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
	video "myreel/kitex_gen/video"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"VideoStream": kitex.NewMethodInfo(
		videoStreamHandler,
		newVideoStreamArgs,
		newVideoStreamResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetVideoUploadToken": kitex.NewMethodInfo(
		getVideoUploadTokenHandler,
		newGetVideoUploadTokenArgs,
		newGetVideoUploadTokenResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetVideoCoverUploadToken": kitex.NewMethodInfo(
		getVideoCoverUploadTokenHandler,
		newGetVideoCoverUploadTokenArgs,
		newGetVideoCoverUploadTokenResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SaveVideo": kitex.NewMethodInfo(
		saveVideoHandler,
		newSaveVideoArgs,
		newSaveVideoResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"PublishList": kitex.NewMethodInfo(
		publishListHandler,
		newPublishListArgs,
		newPublishListResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"Popular": kitex.NewMethodInfo(
		popularHandler,
		newPopularArgs,
		newPopularResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"Search": kitex.NewMethodInfo(
		searchHandler,
		newSearchArgs,
		newSearchResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"VideoLikeAction": kitex.NewMethodInfo(
		videoLikeActionHandler,
		newVideoLikeActionArgs,
		newVideoLikeActionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetVideosByIds": kitex.NewMethodInfo(
		getVideosByIdsHandler,
		newGetVideosByIdsArgs,
		newGetVideosByIdsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AddCommentCount": kitex.NewMethodInfo(
		addCommentCountHandler,
		newAddCommentCountArgs,
		newAddCommentCountResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	videoServiceServiceInfo                = NewServiceInfo()
	videoServiceServiceInfoForClient       = NewServiceInfoForClient()
	videoServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return videoServiceServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return videoServiceServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return videoServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "VideoService"
	handlerType := (*video.VideoService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "video",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.15.2",
		Extra:           extra,
	}
	return svcInfo
}

func videoStreamHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.VideoStreamRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).VideoStream(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *VideoStreamArgs:
		success, err := handler.(video.VideoService).VideoStream(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*VideoStreamResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newVideoStreamArgs() interface{} {
	return &VideoStreamArgs{}
}

func newVideoStreamResult() interface{} {
	return &VideoStreamResult{}
}

type VideoStreamArgs struct {
	Req *video.VideoStreamRequest
}

func (p *VideoStreamArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *VideoStreamArgs) Unmarshal(in []byte) error {
	msg := new(video.VideoStreamRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var VideoStreamArgs_Req_DEFAULT *video.VideoStreamRequest

func (p *VideoStreamArgs) GetReq() *video.VideoStreamRequest {
	if !p.IsSetReq() {
		return VideoStreamArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *VideoStreamArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *VideoStreamArgs) GetFirstArgument() interface{} {
	return p.Req
}

type VideoStreamResult struct {
	Success *video.VideoStreamResponse
}

var VideoStreamResult_Success_DEFAULT *video.VideoStreamResponse

func (p *VideoStreamResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *VideoStreamResult) Unmarshal(in []byte) error {
	msg := new(video.VideoStreamResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *VideoStreamResult) GetSuccess() *video.VideoStreamResponse {
	if !p.IsSetSuccess() {
		return VideoStreamResult_Success_DEFAULT
	}
	return p.Success
}

func (p *VideoStreamResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.VideoStreamResponse)
}

func (p *VideoStreamResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *VideoStreamResult) GetResult() interface{} {
	return p.Success
}

func getVideoUploadTokenHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.GetVideoUploadTokenRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).GetVideoUploadToken(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetVideoUploadTokenArgs:
		success, err := handler.(video.VideoService).GetVideoUploadToken(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetVideoUploadTokenResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetVideoUploadTokenArgs() interface{} {
	return &GetVideoUploadTokenArgs{}
}

func newGetVideoUploadTokenResult() interface{} {
	return &GetVideoUploadTokenResult{}
}

type GetVideoUploadTokenArgs struct {
	Req *video.GetVideoUploadTokenRequest
}

func (p *GetVideoUploadTokenArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetVideoUploadTokenArgs) Unmarshal(in []byte) error {
	msg := new(video.GetVideoUploadTokenRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetVideoUploadTokenArgs_Req_DEFAULT *video.GetVideoUploadTokenRequest

func (p *GetVideoUploadTokenArgs) GetReq() *video.GetVideoUploadTokenRequest {
	if !p.IsSetReq() {
		return GetVideoUploadTokenArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetVideoUploadTokenArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetVideoUploadTokenArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetVideoUploadTokenResult struct {
	Success *video.GetVideoUploadTokenResponse
}

var GetVideoUploadTokenResult_Success_DEFAULT *video.GetVideoUploadTokenResponse

func (p *GetVideoUploadTokenResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetVideoUploadTokenResult) Unmarshal(in []byte) error {
	msg := new(video.GetVideoUploadTokenResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetVideoUploadTokenResult) GetSuccess() *video.GetVideoUploadTokenResponse {
	if !p.IsSetSuccess() {
		return GetVideoUploadTokenResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetVideoUploadTokenResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.GetVideoUploadTokenResponse)
}

func (p *GetVideoUploadTokenResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetVideoUploadTokenResult) GetResult() interface{} {
	return p.Success
}

func getVideoCoverUploadTokenHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.GetVideoCoverUploadTokenRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).GetVideoCoverUploadToken(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetVideoCoverUploadTokenArgs:
		success, err := handler.(video.VideoService).GetVideoCoverUploadToken(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetVideoCoverUploadTokenResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetVideoCoverUploadTokenArgs() interface{} {
	return &GetVideoCoverUploadTokenArgs{}
}

func newGetVideoCoverUploadTokenResult() interface{} {
	return &GetVideoCoverUploadTokenResult{}
}

type GetVideoCoverUploadTokenArgs struct {
	Req *video.GetVideoCoverUploadTokenRequest
}

func (p *GetVideoCoverUploadTokenArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetVideoCoverUploadTokenArgs) Unmarshal(in []byte) error {
	msg := new(video.GetVideoCoverUploadTokenRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetVideoCoverUploadTokenArgs_Req_DEFAULT *video.GetVideoCoverUploadTokenRequest

func (p *GetVideoCoverUploadTokenArgs) GetReq() *video.GetVideoCoverUploadTokenRequest {
	if !p.IsSetReq() {
		return GetVideoCoverUploadTokenArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetVideoCoverUploadTokenArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetVideoCoverUploadTokenArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetVideoCoverUploadTokenResult struct {
	Success *video.GetVideoCoverUploadTokenResponse
}

var GetVideoCoverUploadTokenResult_Success_DEFAULT *video.GetVideoCoverUploadTokenResponse

func (p *GetVideoCoverUploadTokenResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetVideoCoverUploadTokenResult) Unmarshal(in []byte) error {
	msg := new(video.GetVideoCoverUploadTokenResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetVideoCoverUploadTokenResult) GetSuccess() *video.GetVideoCoverUploadTokenResponse {
	if !p.IsSetSuccess() {
		return GetVideoCoverUploadTokenResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetVideoCoverUploadTokenResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.GetVideoCoverUploadTokenResponse)
}

func (p *GetVideoCoverUploadTokenResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetVideoCoverUploadTokenResult) GetResult() interface{} {
	return p.Success
}

func saveVideoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.SaveVideoRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).SaveVideo(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SaveVideoArgs:
		success, err := handler.(video.VideoService).SaveVideo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SaveVideoResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSaveVideoArgs() interface{} {
	return &SaveVideoArgs{}
}

func newSaveVideoResult() interface{} {
	return &SaveVideoResult{}
}

type SaveVideoArgs struct {
	Req *video.SaveVideoRequest
}

func (p *SaveVideoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SaveVideoArgs) Unmarshal(in []byte) error {
	msg := new(video.SaveVideoRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SaveVideoArgs_Req_DEFAULT *video.SaveVideoRequest

func (p *SaveVideoArgs) GetReq() *video.SaveVideoRequest {
	if !p.IsSetReq() {
		return SaveVideoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SaveVideoArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SaveVideoArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SaveVideoResult struct {
	Success *video.SaveVideoResponse
}

var SaveVideoResult_Success_DEFAULT *video.SaveVideoResponse

func (p *SaveVideoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SaveVideoResult) Unmarshal(in []byte) error {
	msg := new(video.SaveVideoResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SaveVideoResult) GetSuccess() *video.SaveVideoResponse {
	if !p.IsSetSuccess() {
		return SaveVideoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SaveVideoResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.SaveVideoResponse)
}

func (p *SaveVideoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SaveVideoResult) GetResult() interface{} {
	return p.Success
}

func publishListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.PublishListRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).PublishList(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *PublishListArgs:
		success, err := handler.(video.VideoService).PublishList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*PublishListResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newPublishListArgs() interface{} {
	return &PublishListArgs{}
}

func newPublishListResult() interface{} {
	return &PublishListResult{}
}

type PublishListArgs struct {
	Req *video.PublishListRequest
}

func (p *PublishListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *PublishListArgs) Unmarshal(in []byte) error {
	msg := new(video.PublishListRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var PublishListArgs_Req_DEFAULT *video.PublishListRequest

func (p *PublishListArgs) GetReq() *video.PublishListRequest {
	if !p.IsSetReq() {
		return PublishListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *PublishListArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *PublishListArgs) GetFirstArgument() interface{} {
	return p.Req
}

type PublishListResult struct {
	Success *video.PublishListResponse
}

var PublishListResult_Success_DEFAULT *video.PublishListResponse

func (p *PublishListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *PublishListResult) Unmarshal(in []byte) error {
	msg := new(video.PublishListResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *PublishListResult) GetSuccess() *video.PublishListResponse {
	if !p.IsSetSuccess() {
		return PublishListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *PublishListResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.PublishListResponse)
}

func (p *PublishListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *PublishListResult) GetResult() interface{} {
	return p.Success
}

func popularHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.PopularRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).Popular(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *PopularArgs:
		success, err := handler.(video.VideoService).Popular(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*PopularResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newPopularArgs() interface{} {
	return &PopularArgs{}
}

func newPopularResult() interface{} {
	return &PopularResult{}
}

type PopularArgs struct {
	Req *video.PopularRequest
}

func (p *PopularArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *PopularArgs) Unmarshal(in []byte) error {
	msg := new(video.PopularRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var PopularArgs_Req_DEFAULT *video.PopularRequest

func (p *PopularArgs) GetReq() *video.PopularRequest {
	if !p.IsSetReq() {
		return PopularArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *PopularArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *PopularArgs) GetFirstArgument() interface{} {
	return p.Req
}

type PopularResult struct {
	Success *video.PopularResponse
}

var PopularResult_Success_DEFAULT *video.PopularResponse

func (p *PopularResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *PopularResult) Unmarshal(in []byte) error {
	msg := new(video.PopularResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *PopularResult) GetSuccess() *video.PopularResponse {
	if !p.IsSetSuccess() {
		return PopularResult_Success_DEFAULT
	}
	return p.Success
}

func (p *PopularResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.PopularResponse)
}

func (p *PopularResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *PopularResult) GetResult() interface{} {
	return p.Success
}

func searchHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.SearchRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).Search(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SearchArgs:
		success, err := handler.(video.VideoService).Search(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SearchResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSearchArgs() interface{} {
	return &SearchArgs{}
}

func newSearchResult() interface{} {
	return &SearchResult{}
}

type SearchArgs struct {
	Req *video.SearchRequest
}

func (p *SearchArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SearchArgs) Unmarshal(in []byte) error {
	msg := new(video.SearchRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SearchArgs_Req_DEFAULT *video.SearchRequest

func (p *SearchArgs) GetReq() *video.SearchRequest {
	if !p.IsSetReq() {
		return SearchArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SearchArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SearchArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SearchResult struct {
	Success *video.SearchResponse
}

var SearchResult_Success_DEFAULT *video.SearchResponse

func (p *SearchResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SearchResult) Unmarshal(in []byte) error {
	msg := new(video.SearchResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SearchResult) GetSuccess() *video.SearchResponse {
	if !p.IsSetSuccess() {
		return SearchResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SearchResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.SearchResponse)
}

func (p *SearchResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SearchResult) GetResult() interface{} {
	return p.Success
}

func videoLikeActionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.VideoLikeActionRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).VideoLikeAction(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *VideoLikeActionArgs:
		success, err := handler.(video.VideoService).VideoLikeAction(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*VideoLikeActionResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newVideoLikeActionArgs() interface{} {
	return &VideoLikeActionArgs{}
}

func newVideoLikeActionResult() interface{} {
	return &VideoLikeActionResult{}
}

type VideoLikeActionArgs struct {
	Req *video.VideoLikeActionRequest
}

func (p *VideoLikeActionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *VideoLikeActionArgs) Unmarshal(in []byte) error {
	msg := new(video.VideoLikeActionRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var VideoLikeActionArgs_Req_DEFAULT *video.VideoLikeActionRequest

func (p *VideoLikeActionArgs) GetReq() *video.VideoLikeActionRequest {
	if !p.IsSetReq() {
		return VideoLikeActionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *VideoLikeActionArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *VideoLikeActionArgs) GetFirstArgument() interface{} {
	return p.Req
}

type VideoLikeActionResult struct {
	Success *video.VideoLikeActionResponse
}

var VideoLikeActionResult_Success_DEFAULT *video.VideoLikeActionResponse

func (p *VideoLikeActionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *VideoLikeActionResult) Unmarshal(in []byte) error {
	msg := new(video.VideoLikeActionResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *VideoLikeActionResult) GetSuccess() *video.VideoLikeActionResponse {
	if !p.IsSetSuccess() {
		return VideoLikeActionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *VideoLikeActionResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.VideoLikeActionResponse)
}

func (p *VideoLikeActionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *VideoLikeActionResult) GetResult() interface{} {
	return p.Success
}

func getVideosByIdsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.GetVideosByIdsRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).GetVideosByIds(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetVideosByIdsArgs:
		success, err := handler.(video.VideoService).GetVideosByIds(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetVideosByIdsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetVideosByIdsArgs() interface{} {
	return &GetVideosByIdsArgs{}
}

func newGetVideosByIdsResult() interface{} {
	return &GetVideosByIdsResult{}
}

type GetVideosByIdsArgs struct {
	Req *video.GetVideosByIdsRequest
}

func (p *GetVideosByIdsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetVideosByIdsArgs) Unmarshal(in []byte) error {
	msg := new(video.GetVideosByIdsRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetVideosByIdsArgs_Req_DEFAULT *video.GetVideosByIdsRequest

func (p *GetVideosByIdsArgs) GetReq() *video.GetVideosByIdsRequest {
	if !p.IsSetReq() {
		return GetVideosByIdsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetVideosByIdsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetVideosByIdsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetVideosByIdsResult struct {
	Success *video.GetVideosByIdsResponse
}

var GetVideosByIdsResult_Success_DEFAULT *video.GetVideosByIdsResponse

func (p *GetVideosByIdsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetVideosByIdsResult) Unmarshal(in []byte) error {
	msg := new(video.GetVideosByIdsResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetVideosByIdsResult) GetSuccess() *video.GetVideosByIdsResponse {
	if !p.IsSetSuccess() {
		return GetVideosByIdsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetVideosByIdsResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.GetVideosByIdsResponse)
}

func (p *GetVideosByIdsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetVideosByIdsResult) GetResult() interface{} {
	return p.Success
}

func addCommentCountHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.AddCommentCountRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).AddCommentCount(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AddCommentCountArgs:
		success, err := handler.(video.VideoService).AddCommentCount(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AddCommentCountResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAddCommentCountArgs() interface{} {
	return &AddCommentCountArgs{}
}

func newAddCommentCountResult() interface{} {
	return &AddCommentCountResult{}
}

type AddCommentCountArgs struct {
	Req *video.AddCommentCountRequest
}

func (p *AddCommentCountArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AddCommentCountArgs) Unmarshal(in []byte) error {
	msg := new(video.AddCommentCountRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AddCommentCountArgs_Req_DEFAULT *video.AddCommentCountRequest

func (p *AddCommentCountArgs) GetReq() *video.AddCommentCountRequest {
	if !p.IsSetReq() {
		return AddCommentCountArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AddCommentCountArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AddCommentCountArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AddCommentCountResult struct {
	Success *video.AddCommentCountResponse
}

var AddCommentCountResult_Success_DEFAULT *video.AddCommentCountResponse

func (p *AddCommentCountResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AddCommentCountResult) Unmarshal(in []byte) error {
	msg := new(video.AddCommentCountResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AddCommentCountResult) GetSuccess() *video.AddCommentCountResponse {
	if !p.IsSetSuccess() {
		return AddCommentCountResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AddCommentCountResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.AddCommentCountResponse)
}

func (p *AddCommentCountResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AddCommentCountResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) VideoStream(ctx context.Context, Req *video.VideoStreamRequest) (r *video.VideoStreamResponse, err error) {
	var _args VideoStreamArgs
	_args.Req = Req
	var _result VideoStreamResult
	if err = p.c.Call(ctx, "VideoStream", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetVideoUploadToken(ctx context.Context, Req *video.GetVideoUploadTokenRequest) (r *video.GetVideoUploadTokenResponse, err error) {
	var _args GetVideoUploadTokenArgs
	_args.Req = Req
	var _result GetVideoUploadTokenResult
	if err = p.c.Call(ctx, "GetVideoUploadToken", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetVideoCoverUploadToken(ctx context.Context, Req *video.GetVideoCoverUploadTokenRequest) (r *video.GetVideoCoverUploadTokenResponse, err error) {
	var _args GetVideoCoverUploadTokenArgs
	_args.Req = Req
	var _result GetVideoCoverUploadTokenResult
	if err = p.c.Call(ctx, "GetVideoCoverUploadToken", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SaveVideo(ctx context.Context, Req *video.SaveVideoRequest) (r *video.SaveVideoResponse, err error) {
	var _args SaveVideoArgs
	_args.Req = Req
	var _result SaveVideoResult
	if err = p.c.Call(ctx, "SaveVideo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) PublishList(ctx context.Context, Req *video.PublishListRequest) (r *video.PublishListResponse, err error) {
	var _args PublishListArgs
	_args.Req = Req
	var _result PublishListResult
	if err = p.c.Call(ctx, "PublishList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Popular(ctx context.Context, Req *video.PopularRequest) (r *video.PopularResponse, err error) {
	var _args PopularArgs
	_args.Req = Req
	var _result PopularResult
	if err = p.c.Call(ctx, "Popular", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Search(ctx context.Context, Req *video.SearchRequest) (r *video.SearchResponse, err error) {
	var _args SearchArgs
	_args.Req = Req
	var _result SearchResult
	if err = p.c.Call(ctx, "Search", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) VideoLikeAction(ctx context.Context, Req *video.VideoLikeActionRequest) (r *video.VideoLikeActionResponse, err error) {
	var _args VideoLikeActionArgs
	_args.Req = Req
	var _result VideoLikeActionResult
	if err = p.c.Call(ctx, "VideoLikeAction", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetVideosByIds(ctx context.Context, Req *video.GetVideosByIdsRequest) (r *video.GetVideosByIdsResponse, err error) {
	var _args GetVideosByIdsArgs
	_args.Req = Req
	var _result GetVideosByIdsResult
	if err = p.c.Call(ctx, "GetVideosByIds", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AddCommentCount(ctx context.Context, Req *video.AddCommentCountRequest) (r *video.AddCommentCountResponse, err error) {
	var _args AddCommentCountArgs
	_args.Req = Req
	var _result AddCommentCountResult
	if err = p.c.Call(ctx, "AddCommentCount", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
