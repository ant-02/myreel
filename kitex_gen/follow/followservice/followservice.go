// Code generated by Kitex v0.15.2. DO NOT EDIT.

package followservice

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
	follow "myreel/kitex_gen/follow"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"FollowAction": kitex.NewMethodInfo(
		followActionHandler,
		newFollowActionArgs,
		newFollowActionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"FolloweringList": kitex.NewMethodInfo(
		followeringListHandler,
		newFolloweringListArgs,
		newFolloweringListResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"FolloweredList": kitex.NewMethodInfo(
		followeredListHandler,
		newFolloweredListArgs,
		newFolloweredListResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"FriendList": kitex.NewMethodInfo(
		friendListHandler,
		newFriendListArgs,
		newFriendListResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ChatGroup": kitex.NewMethodInfo(
		chatGroupHandler,
		newChatGroupArgs,
		newChatGroupResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"JoinedChatGroupList": kitex.NewMethodInfo(
		joinedChatGroupListHandler,
		newJoinedChatGroupListArgs,
		newJoinedChatGroupListResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CreatedChatGroupList": kitex.NewMethodInfo(
		createdChatGroupListHandler,
		newCreatedChatGroupListArgs,
		newCreatedChatGroupListResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	followServiceServiceInfo                = NewServiceInfo()
	followServiceServiceInfoForClient       = NewServiceInfoForClient()
	followServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return followServiceServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return followServiceServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return followServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "FollowService"
	handlerType := (*follow.FollowService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "follow",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.15.2",
		Extra:           extra,
	}
	return svcInfo
}

func followActionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(follow.FollowActionRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(follow.FollowService).FollowAction(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *FollowActionArgs:
		success, err := handler.(follow.FollowService).FollowAction(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FollowActionResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newFollowActionArgs() interface{} {
	return &FollowActionArgs{}
}

func newFollowActionResult() interface{} {
	return &FollowActionResult{}
}

type FollowActionArgs struct {
	Req *follow.FollowActionRequest
}

func (p *FollowActionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *FollowActionArgs) Unmarshal(in []byte) error {
	msg := new(follow.FollowActionRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FollowActionArgs_Req_DEFAULT *follow.FollowActionRequest

func (p *FollowActionArgs) GetReq() *follow.FollowActionRequest {
	if !p.IsSetReq() {
		return FollowActionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FollowActionArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *FollowActionArgs) GetFirstArgument() interface{} {
	return p.Req
}

type FollowActionResult struct {
	Success *follow.FollowActionResponse
}

var FollowActionResult_Success_DEFAULT *follow.FollowActionResponse

func (p *FollowActionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *FollowActionResult) Unmarshal(in []byte) error {
	msg := new(follow.FollowActionResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FollowActionResult) GetSuccess() *follow.FollowActionResponse {
	if !p.IsSetSuccess() {
		return FollowActionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FollowActionResult) SetSuccess(x interface{}) {
	p.Success = x.(*follow.FollowActionResponse)
}

func (p *FollowActionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FollowActionResult) GetResult() interface{} {
	return p.Success
}

func followeringListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(follow.FolloweringListRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(follow.FollowService).FolloweringList(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *FolloweringListArgs:
		success, err := handler.(follow.FollowService).FolloweringList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FolloweringListResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newFolloweringListArgs() interface{} {
	return &FolloweringListArgs{}
}

func newFolloweringListResult() interface{} {
	return &FolloweringListResult{}
}

type FolloweringListArgs struct {
	Req *follow.FolloweringListRequest
}

func (p *FolloweringListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *FolloweringListArgs) Unmarshal(in []byte) error {
	msg := new(follow.FolloweringListRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FolloweringListArgs_Req_DEFAULT *follow.FolloweringListRequest

func (p *FolloweringListArgs) GetReq() *follow.FolloweringListRequest {
	if !p.IsSetReq() {
		return FolloweringListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FolloweringListArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *FolloweringListArgs) GetFirstArgument() interface{} {
	return p.Req
}

type FolloweringListResult struct {
	Success *follow.FolloweringListResponse
}

var FolloweringListResult_Success_DEFAULT *follow.FolloweringListResponse

func (p *FolloweringListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *FolloweringListResult) Unmarshal(in []byte) error {
	msg := new(follow.FolloweringListResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FolloweringListResult) GetSuccess() *follow.FolloweringListResponse {
	if !p.IsSetSuccess() {
		return FolloweringListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FolloweringListResult) SetSuccess(x interface{}) {
	p.Success = x.(*follow.FolloweringListResponse)
}

func (p *FolloweringListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FolloweringListResult) GetResult() interface{} {
	return p.Success
}

func followeredListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(follow.FolloweredListRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(follow.FollowService).FolloweredList(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *FolloweredListArgs:
		success, err := handler.(follow.FollowService).FolloweredList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FolloweredListResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newFolloweredListArgs() interface{} {
	return &FolloweredListArgs{}
}

func newFolloweredListResult() interface{} {
	return &FolloweredListResult{}
}

type FolloweredListArgs struct {
	Req *follow.FolloweredListRequest
}

func (p *FolloweredListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *FolloweredListArgs) Unmarshal(in []byte) error {
	msg := new(follow.FolloweredListRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FolloweredListArgs_Req_DEFAULT *follow.FolloweredListRequest

func (p *FolloweredListArgs) GetReq() *follow.FolloweredListRequest {
	if !p.IsSetReq() {
		return FolloweredListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FolloweredListArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *FolloweredListArgs) GetFirstArgument() interface{} {
	return p.Req
}

type FolloweredListResult struct {
	Success *follow.FolloweredListResponse
}

var FolloweredListResult_Success_DEFAULT *follow.FolloweredListResponse

func (p *FolloweredListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *FolloweredListResult) Unmarshal(in []byte) error {
	msg := new(follow.FolloweredListResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FolloweredListResult) GetSuccess() *follow.FolloweredListResponse {
	if !p.IsSetSuccess() {
		return FolloweredListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FolloweredListResult) SetSuccess(x interface{}) {
	p.Success = x.(*follow.FolloweredListResponse)
}

func (p *FolloweredListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FolloweredListResult) GetResult() interface{} {
	return p.Success
}

func friendListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(follow.FriendListRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(follow.FollowService).FriendList(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *FriendListArgs:
		success, err := handler.(follow.FollowService).FriendList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FriendListResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newFriendListArgs() interface{} {
	return &FriendListArgs{}
}

func newFriendListResult() interface{} {
	return &FriendListResult{}
}

type FriendListArgs struct {
	Req *follow.FriendListRequest
}

func (p *FriendListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *FriendListArgs) Unmarshal(in []byte) error {
	msg := new(follow.FriendListRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FriendListArgs_Req_DEFAULT *follow.FriendListRequest

func (p *FriendListArgs) GetReq() *follow.FriendListRequest {
	if !p.IsSetReq() {
		return FriendListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FriendListArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *FriendListArgs) GetFirstArgument() interface{} {
	return p.Req
}

type FriendListResult struct {
	Success *follow.FriendListResponse
}

var FriendListResult_Success_DEFAULT *follow.FriendListResponse

func (p *FriendListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *FriendListResult) Unmarshal(in []byte) error {
	msg := new(follow.FriendListResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FriendListResult) GetSuccess() *follow.FriendListResponse {
	if !p.IsSetSuccess() {
		return FriendListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FriendListResult) SetSuccess(x interface{}) {
	p.Success = x.(*follow.FriendListResponse)
}

func (p *FriendListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FriendListResult) GetResult() interface{} {
	return p.Success
}

func chatGroupHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(follow.ChatGroupRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(follow.FollowService).ChatGroup(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ChatGroupArgs:
		success, err := handler.(follow.FollowService).ChatGroup(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ChatGroupResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newChatGroupArgs() interface{} {
	return &ChatGroupArgs{}
}

func newChatGroupResult() interface{} {
	return &ChatGroupResult{}
}

type ChatGroupArgs struct {
	Req *follow.ChatGroupRequest
}

func (p *ChatGroupArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ChatGroupArgs) Unmarshal(in []byte) error {
	msg := new(follow.ChatGroupRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ChatGroupArgs_Req_DEFAULT *follow.ChatGroupRequest

func (p *ChatGroupArgs) GetReq() *follow.ChatGroupRequest {
	if !p.IsSetReq() {
		return ChatGroupArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ChatGroupArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ChatGroupArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ChatGroupResult struct {
	Success *follow.ChatGroupResponse
}

var ChatGroupResult_Success_DEFAULT *follow.ChatGroupResponse

func (p *ChatGroupResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ChatGroupResult) Unmarshal(in []byte) error {
	msg := new(follow.ChatGroupResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ChatGroupResult) GetSuccess() *follow.ChatGroupResponse {
	if !p.IsSetSuccess() {
		return ChatGroupResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ChatGroupResult) SetSuccess(x interface{}) {
	p.Success = x.(*follow.ChatGroupResponse)
}

func (p *ChatGroupResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChatGroupResult) GetResult() interface{} {
	return p.Success
}

func joinedChatGroupListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(follow.JoinedChatGroupListRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(follow.FollowService).JoinedChatGroupList(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *JoinedChatGroupListArgs:
		success, err := handler.(follow.FollowService).JoinedChatGroupList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*JoinedChatGroupListResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newJoinedChatGroupListArgs() interface{} {
	return &JoinedChatGroupListArgs{}
}

func newJoinedChatGroupListResult() interface{} {
	return &JoinedChatGroupListResult{}
}

type JoinedChatGroupListArgs struct {
	Req *follow.JoinedChatGroupListRequest
}

func (p *JoinedChatGroupListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *JoinedChatGroupListArgs) Unmarshal(in []byte) error {
	msg := new(follow.JoinedChatGroupListRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var JoinedChatGroupListArgs_Req_DEFAULT *follow.JoinedChatGroupListRequest

func (p *JoinedChatGroupListArgs) GetReq() *follow.JoinedChatGroupListRequest {
	if !p.IsSetReq() {
		return JoinedChatGroupListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *JoinedChatGroupListArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *JoinedChatGroupListArgs) GetFirstArgument() interface{} {
	return p.Req
}

type JoinedChatGroupListResult struct {
	Success *follow.JoinedChatGroupListResponse
}

var JoinedChatGroupListResult_Success_DEFAULT *follow.JoinedChatGroupListResponse

func (p *JoinedChatGroupListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *JoinedChatGroupListResult) Unmarshal(in []byte) error {
	msg := new(follow.JoinedChatGroupListResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *JoinedChatGroupListResult) GetSuccess() *follow.JoinedChatGroupListResponse {
	if !p.IsSetSuccess() {
		return JoinedChatGroupListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *JoinedChatGroupListResult) SetSuccess(x interface{}) {
	p.Success = x.(*follow.JoinedChatGroupListResponse)
}

func (p *JoinedChatGroupListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *JoinedChatGroupListResult) GetResult() interface{} {
	return p.Success
}

func createdChatGroupListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(follow.CreatedChatGroupListRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(follow.FollowService).CreatedChatGroupList(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreatedChatGroupListArgs:
		success, err := handler.(follow.FollowService).CreatedChatGroupList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreatedChatGroupListResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreatedChatGroupListArgs() interface{} {
	return &CreatedChatGroupListArgs{}
}

func newCreatedChatGroupListResult() interface{} {
	return &CreatedChatGroupListResult{}
}

type CreatedChatGroupListArgs struct {
	Req *follow.CreatedChatGroupListRequest
}

func (p *CreatedChatGroupListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreatedChatGroupListArgs) Unmarshal(in []byte) error {
	msg := new(follow.CreatedChatGroupListRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreatedChatGroupListArgs_Req_DEFAULT *follow.CreatedChatGroupListRequest

func (p *CreatedChatGroupListArgs) GetReq() *follow.CreatedChatGroupListRequest {
	if !p.IsSetReq() {
		return CreatedChatGroupListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreatedChatGroupListArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreatedChatGroupListArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreatedChatGroupListResult struct {
	Success *follow.CreatedChatGroupListResponse
}

var CreatedChatGroupListResult_Success_DEFAULT *follow.CreatedChatGroupListResponse

func (p *CreatedChatGroupListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreatedChatGroupListResult) Unmarshal(in []byte) error {
	msg := new(follow.CreatedChatGroupListResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreatedChatGroupListResult) GetSuccess() *follow.CreatedChatGroupListResponse {
	if !p.IsSetSuccess() {
		return CreatedChatGroupListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreatedChatGroupListResult) SetSuccess(x interface{}) {
	p.Success = x.(*follow.CreatedChatGroupListResponse)
}

func (p *CreatedChatGroupListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreatedChatGroupListResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) FollowAction(ctx context.Context, Req *follow.FollowActionRequest) (r *follow.FollowActionResponse, err error) {
	var _args FollowActionArgs
	_args.Req = Req
	var _result FollowActionResult
	if err = p.c.Call(ctx, "FollowAction", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) FolloweringList(ctx context.Context, Req *follow.FolloweringListRequest) (r *follow.FolloweringListResponse, err error) {
	var _args FolloweringListArgs
	_args.Req = Req
	var _result FolloweringListResult
	if err = p.c.Call(ctx, "FolloweringList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) FolloweredList(ctx context.Context, Req *follow.FolloweredListRequest) (r *follow.FolloweredListResponse, err error) {
	var _args FolloweredListArgs
	_args.Req = Req
	var _result FolloweredListResult
	if err = p.c.Call(ctx, "FolloweredList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) FriendList(ctx context.Context, Req *follow.FriendListRequest) (r *follow.FriendListResponse, err error) {
	var _args FriendListArgs
	_args.Req = Req
	var _result FriendListResult
	if err = p.c.Call(ctx, "FriendList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ChatGroup(ctx context.Context, Req *follow.ChatGroupRequest) (r *follow.ChatGroupResponse, err error) {
	var _args ChatGroupArgs
	_args.Req = Req
	var _result ChatGroupResult
	if err = p.c.Call(ctx, "ChatGroup", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) JoinedChatGroupList(ctx context.Context, Req *follow.JoinedChatGroupListRequest) (r *follow.JoinedChatGroupListResponse, err error) {
	var _args JoinedChatGroupListArgs
	_args.Req = Req
	var _result JoinedChatGroupListResult
	if err = p.c.Call(ctx, "JoinedChatGroupList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreatedChatGroupList(ctx context.Context, Req *follow.CreatedChatGroupListRequest) (r *follow.CreatedChatGroupListResponse, err error) {
	var _args CreatedChatGroupListArgs
	_args.Req = Req
	var _result CreatedChatGroupListResult
	if err = p.c.Call(ctx, "CreatedChatGroupList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
